{% extends 'base.html' %}

{% block title %}Product Icon Generator - Batch Results{% endblock %}

{% block content %}
<style>
    .preview-modal .modal-content {
        background: #1a1a2e;
        border: 2px solid #667eea;
        border-radius: 15px;
    }
    .preview-modal .modal-header {
        border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    .preview-modal .modal-title {
        color: #fff;
    }
    .preview-modal .btn-close {
        filter: invert(1);
    }
    .preview-canvas-wrapper {
        position: relative;
        display: inline-block;
        border: 3px solid #667eea;
        border-radius: 10px;
        overflow: hidden;
        cursor: move;
        width: 440px;  /* Fixed width: 800 * 0.55 = 440px */
        height: 440px; /* Fixed height: 800 * 0.55 = 440px */
    }
    #modalPreviewCanvas {
        display: block;
        width: 440px !important;  /* Fixed display width */
        height: 440px !important; /* Fixed display height */
    }
    .preview-controls {
        background: rgba(255,255,255,0.1);
        border-radius: 10px;
        padding: 15px;
        margin-top: 15px;
    }
    .preview-controls label {
        color: #fff;
        font-weight: 500;
    }
    .preview-controls input[type="number"] {
        background: rgba(255,255,255,0.9);
        border: 2px solid #667eea;
        border-radius: 8px;
        padding: 6px 10px;
        width: 90px;
        font-weight: 600;
    }
    .preview-controls .form-check-label {
        color: #ccc;
    }
    .btn-preview {
        border-radius: 25px;
        padding: 8px 20px;
        font-weight: 600;
        transition: all 0.3s ease;
    }
    .btn-edit-product {
        background: linear-gradient(45deg, #f39c12, #e74c3c);
        border: none;
        color: white;
    }
    .btn-edit-product:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(243, 156, 18, 0.4);
        color: white;
    }
    .btn-reset {
        background: linear-gradient(45deg, #95a5a6, #7f8c8d);
        border: none;
        color: white;
    }
    .btn-download-custom {
        background: linear-gradient(45deg, #27ae60, #2ecc71);
        border: none;
        color: white;
    }
    .btn-mirror {
        background: linear-gradient(45deg, #667eea, #764ba2);
        border: none;
        color: white;
    }
    .btn-mirror:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        color: white;
    }
    .btn-mirror.active {
        background: linear-gradient(45deg, #764ba2, #667eea);
        box-shadow: 0 0 10px rgba(102, 126, 234, 0.6);
    }
    .editing-hint {
        color: #a0a0a0;
        font-size: 0.8rem;
        margin-top: 10px;
    }
</style>

<div class="row justify-content-center">
    <div class="col-md-12">
        <div class="card">
            <div class="card-header bg-success text-white text-center">
                <h3><i class="fas fa-check-circle me-2"></i>{{ products.count }} Product Image(s) Generated Successfully!</h3>
            </div>
            <div class="card-body">
                
                <!-- Results Grid -->
                <div class="row">
                    {% for product in products %}
                    <div class="col-md-6 col-lg-4 mb-4">
                        <div class="card h-100">
                            <div class="card-header bg-light">
                                <strong>Image {{ forloop.counter }}</strong>
                            </div>
                            <div class="card-body">
                                <div class="row">
                                    <div class="col-6">
                                        <p class="text-muted small mb-1">Original</p>
                                        <img src="{{ product.product_image.url }}" 
                                             alt="Original" 
                                             class="img-fluid rounded shadow-sm"
                                             style="max-height: 120px;">
                                    </div>
                                    <div class="col-6">
                                        <p class="text-muted small mb-1">Result</p>
                                        <img src="{{ product.result_image.url }}" 
                                             alt="Result" 
                                             class="img-fluid rounded shadow-sm"
                                             style="max-height: 120px;">
                                    </div>
                                </div>
                            </div>
                            <div class="card-footer text-center">
                                <button onclick="openPreviewEditor({{ forloop.counter0 }}, '{{ product.product_image.url }}', '{{ product.result_image.url }}')" 
                                        class="btn btn-edit-product btn-sm me-1">
                                    <i class="fas fa-edit me-1"></i>Edit
                                </button>
                                <button onclick="downloadWithRename('{{ product.result_image.url }}')" 
                                        class="btn btn-success btn-sm">
                                    <i class="fas fa-download me-1"></i>Download
                                </button>
                            </div>
                        </div>
                    </div>
                    {% endfor %}
                </div>

                <hr class="my-4">

                <!-- Summary and Actions -->
                <div class="row">
                    <div class="col-md-6">
                        <h5><i class="fas fa-info-circle me-2"></i>Batch Summary</h5>
                        <ul class="list-group list-group-flush">
                            <li class="list-group-item d-flex justify-content-between">
                                <span>Total Images:</span>
                                <span class="badge bg-primary">{{ products.count }}</span>
                            </li>
                            <li class="list-group-item d-flex justify-content-between">
                                <span>Created:</span>
                                <span class="text-muted">{{ batch.created_at|date:"M d, Y H:i" }}</span>
                            </li>
                        </ul>
                    </div>
                    <div class="col-md-6">
                        <h5><i class="fas fa-arrows-alt-v me-2"></i>Vertical Pictos Applied</h5>
                        <ul class="list-group list-group-flush small">
                            {% if batch.vertical_pos_1 %}
                            <li class="list-group-item py-1">Pos 1: {{ batch.vertical_pos_1 }}</li>
                            {% endif %}
                            {% if batch.vertical_pos_2 %}
                            <li class="list-group-item py-1">Pos 2: {{ batch.vertical_pos_2 }}</li>
                            {% endif %}
                            {% if batch.vertical_pos_3 %}
                            <li class="list-group-item py-1">Pos 3: {{ batch.vertical_pos_3 }}</li>
                            {% endif %}
                            {% if batch.vertical_pos_4 %}
                            <li class="list-group-item py-1">Pos 4: {{ batch.vertical_pos_4 }}</li>
                            {% endif %}
                            {% if batch.vertical_pos_5 %}
                            <li class="list-group-item py-1">Pos 5: {{ batch.vertical_pos_5 }}</li>
                            {% endif %}
                        </ul>
                    </div>
                </div>

                <div class="text-center mt-4">
                    <a href="{% url 'home' %}" class="btn btn-primary btn-lg">
                        <i class="fas fa-plus me-2"></i>Generate More Images
                    </a>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Preview Editor Modal -->
<div class="modal fade preview-modal" id="previewModal" tabindex="-1" aria-labelledby="previewModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="previewModalLabel"><i class="fas fa-edit me-2"></i>Preview Mode - Edit Product</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body text-center">
                <div class="preview-canvas-wrapper" id="modalCanvasWrapper">
                    <canvas id="modalPreviewCanvas" width="800" height="800"></canvas>
                </div>
                
                <div class="preview-controls">
                    <div class="row justify-content-center align-items-center g-2">
                        <div class="col-auto">
                            <label for="modalProductWidth" class="me-2">Largeur:</label>
                            <input type="number" id="modalProductWidth" value="350" min="50" max="700" step="10">
                        </div>
                        <div class="col-auto">
                            <label for="modalProductHeight" class="me-2">Hauteur:</label>
                            <input type="number" id="modalProductHeight" value="350" min="50" max="700" step="10">
                        </div>
                        <div class="col-auto">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="modalLockAspectRatio" checked>
                                <label class="form-check-label" for="modalLockAspectRatio">
                                    <i class="fas fa-lock me-1"></i>Lock Ratio
                                </label>
                            </div>
                        </div>
                        <div class="col-auto">
                            <button class="btn btn-sm btn-preview btn-mirror" id="modalMirrorBtn" onclick="modalPreviewEditor.flipHorizontal()" title="Inverser l'image horizontalement">
                                <i class="fas fa-arrows-alt-h me-1"></i>Inverser
                            </button>
                        </div>
                    </div>
                    <div class="mt-3">
                        <button class="btn btn-preview btn-reset me-2" onclick="modalPreviewEditor.reset()">
                            <i class="fas fa-undo me-1"></i>Reset
                        </button>
                        <button class="btn btn-preview btn-download-custom" onclick="modalPreviewEditor.downloadCustom()">
                            <i class="fas fa-download me-1"></i>Download Custom
                        </button>
                    </div>
                    <p class="editing-hint"><i class="fas fa-info-circle me-1"></i>Drag the product image to reposition. Use controls to resize.</p>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
// Download with rename function
function downloadWithRename(imageUrl) {
    const urlParts = imageUrl.split('/');
    let filename = urlParts[urlParts.length - 1];
    filename = filename.split('?')[0];
    const baseName = filename.replace(/\.[^/.]+$/, '') || 'result';
    
    const userFilename = prompt('Enter filename for download:', baseName);
    if (userFilename === null) return;
    
    const cleanFilename = userFilename.replace(/[<>:"/\\|?*]/g, '_').trim();
    if (!cleanFilename) {
        alert('Filename cannot be empty!');
        return;
    }
    
    const originalExt = filename.match(/\.[^/.]+$/) ? filename.match(/\.[^/.]+$/)[0] : '.webp';
    const finalFilename = cleanFilename.endsWith(originalExt) ? cleanFilename : cleanFilename + originalExt;
    
    fetch(imageUrl)
        .then(response => response.blob())
        .then(blob => {
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = finalFilename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        })
        .catch(error => {
            console.error('Download error:', error);
            alert('Error downloading image. Please try again.');
        });
}

// Modal Preview Editor Class
class ModalPreviewEditor {
    constructor(canvasId, widthInputId, heightInputId, lockRatioId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.widthInput = document.getElementById(widthInputId);
        this.heightInput = document.getElementById(heightInputId);
        this.lockRatioCheckbox = document.getElementById(lockRatioId);
        
        // Canvas dimensions - FIXED and NEVER changes
        // Internal canvas size is always 800x800 pixels
        this.canvas.width = 800;  // Fixed internal width
        this.canvas.height = 800; // Fixed internal height
        
        // Display scale (55% for display in modal)
        this.displayScale = 0.55;
        this.canvas.style.width = '440px';   // Fixed display width: 800 * 0.55
        this.canvas.style.height = '440px';  // Fixed display height: 800 * 0.55
        
        // Images
        this.backgroundImg = null;
        this.productImg = null;
        this.verticalPictos = [];
        this.horizontalPictos = [];
        
        // Product state
        this.product = {
            x: 400,
            y: 400,
            width: 350,
            height: 350,
            originalWidth: 350,
            originalHeight: 350,
            aspectRatio: 1,
            flipped: false  // Track if image is horizontally flipped
        };
        
        // Fixed frame center position (NEVER changes)
        this.frameCenter = {
            x: 400,
            y: 400
        };
        
        // FIXED reference frame - ALWAYS 450x450, NEVER changes
        // Using Object.freeze to make it immutable
        this.fixedFrame = Object.freeze({
            centerX: 400,
            centerY: 400,
            width: 450,
            height: 450
        });
        
        // Show reference frame
        this.showGuides = true;
        
        // Drag state
        this.isDragging = false;
        this.dragOffset = { x: 0, y: 0 };
        
        // Prevent recursive updates
        this.isUpdatingInput = false;
        
        // Bind events
        this.bindEvents();
    }
    
    bindEvents() {
        // Mouse events
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        document.addEventListener('mousemove', (e) => this.onMouseMove(e));
        document.addEventListener('mouseup', () => this.onMouseUp());
        
        // Touch events
        this.canvas.addEventListener('touchstart', (e) => this.onTouchStart(e));
        document.addEventListener('touchmove', (e) => this.onTouchMove(e));
        document.addEventListener('touchend', () => this.onMouseUp());
        
        // Size inputs
        this.widthInput.addEventListener('input', (e) => this.onWidthChange(e));
        this.heightInput.addEventListener('input', (e) => this.onHeightChange(e));
        
        // Lock ratio checkbox - update aspect ratio when toggled
        this.lockRatioCheckbox.addEventListener('change', (e) => this.onLockRatioToggle(e));
    }
    
    onLockRatioToggle(e) {
        // When lock is turned ON, update aspect ratio based on current dimensions
        if (e.target.checked && this.product.width > 0 && this.product.height > 0) {
            this.product.aspectRatio = this.product.width / this.product.height;
        }
        // When lock is turned OFF, allow free resizing (aspect ratio will update on next change)
    }
    
    getCanvasCoords(e) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = 800 / rect.width;
        const scaleY = 800 / rect.height;
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
        };
    }
    
    isPointInProduct(x, y) {
        const halfW = this.product.width / 2;
        const halfH = this.product.height / 2;
        return x >= this.product.x - halfW && 
               x <= this.product.x + halfW &&
               y >= this.product.y - halfH && 
               y <= this.product.y + halfH;
    }
    
    onMouseDown(e) {
        const coords = this.getCanvasCoords(e);
        if (this.isPointInProduct(coords.x, coords.y)) {
            this.isDragging = true;
            this.dragOffset.x = coords.x - this.product.x;
            this.dragOffset.y = coords.y - this.product.y;
            this.canvas.style.cursor = 'grabbing';
        }
    }
    
    onMouseMove(e) {
        if (!this.isDragging) return;
        
        const coords = this.getCanvasCoords(e);
        this.product.x = coords.x - this.dragOffset.x;
        this.product.y = coords.y - this.dragOffset.y;
        
        const halfW = this.product.width / 2;
        const halfH = this.product.height / 2;
        this.product.x = Math.max(halfW, Math.min(800 - halfW, this.product.x));
        this.product.y = Math.max(halfH, Math.min(800 - halfH, this.product.y));
        
        this.render();
    }
    
    onMouseUp() {
        this.isDragging = false;
        this.canvas.style.cursor = 'move';
    }
    
    onTouchStart(e) {
        e.preventDefault();
        const touch = e.touches[0];
        this.onMouseDown({ clientX: touch.clientX, clientY: touch.clientY });
    }
    
    onTouchMove(e) {
        if (!this.isDragging) return;
        e.preventDefault();
        const touch = e.touches[0];
        this.onMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
    }
    
    onWidthChange(e) {
        // Prevent recursive updates
        if (this.isUpdatingInput) return;
        
        const newWidth = parseInt(e.target.value) || 350;
        
        // Clamp to valid range
        const clampedWidth = Math.max(50, Math.min(700, newWidth));
        if (clampedWidth !== newWidth) {
            this.isUpdatingInput = true;
            e.target.value = clampedWidth;
            this.isUpdatingInput = false;
        }
        
        this.product.width = clampedWidth;
        
        if (this.lockRatioCheckbox.checked) {
            // Lock aspect ratio: adjust height based on width
            this.product.height = Math.round(clampedWidth / this.product.aspectRatio);
            // Update height input without triggering its change event
            this.isUpdatingInput = true;
            this.heightInput.value = this.product.height;
            this.isUpdatingInput = false;
        } else {
            // Free resize: update aspect ratio based on current dimensions
            if (this.product.height > 0) {
                this.product.aspectRatio = this.product.width / this.product.height;
            }
        }
        
        this.render();
    }
    
    onHeightChange(e) {
        // Prevent recursive updates
        if (this.isUpdatingInput) return;
        
        const newHeight = parseInt(e.target.value) || 350;
        
        // Clamp to valid range
        const clampedHeight = Math.max(50, Math.min(700, newHeight));
        if (clampedHeight !== newHeight) {
            this.isUpdatingInput = true;
            e.target.value = clampedHeight;
            this.isUpdatingInput = false;
        }
        
        this.product.height = clampedHeight;
        
        if (this.lockRatioCheckbox.checked) {
            // Lock aspect ratio: adjust width based on height
            this.product.width = Math.round(clampedHeight * this.product.aspectRatio);
            // Update width input without triggering its change event
            this.isUpdatingInput = true;
            this.widthInput.value = this.product.width;
            this.isUpdatingInput = false;
        } else {
            // Free resize: update aspect ratio based on current dimensions
            if (this.product.width > 0) {
                this.product.aspectRatio = this.product.width / this.product.height;
            }
        }
        
        this.render();
    }
    
    async loadForProduct(productImageUrl) {
        try {
            // Reset state
            this.verticalPictos = [];
            this.horizontalPictos = [];
            this.product.x = 400;
            this.product.y = 400;
            this.product.flipped = false;  // Reset flip state when loading new product
            
            // Reset mirror button state
            const mirrorBtn = document.getElementById('modalMirrorBtn');
            if (mirrorBtn) {
                mirrorBtn.classList.remove('active');
            }
            
            // Load background
            this.backgroundImg = await this.loadImage('/backgrounds/background.jpg');
            
            // Load product image
            this.productImg = await this.loadImage(productImageUrl);
            
            // Calculate initial product size
            const maxSize = 350;
            if (this.productImg.width > this.productImg.height) {
                this.product.width = maxSize;
                this.product.height = Math.round((this.productImg.height * maxSize) / this.productImg.width);
            } else {
                this.product.height = maxSize;
                this.product.width = Math.round((this.productImg.width * maxSize) / this.productImg.height);
            }
            this.product.originalWidth = this.product.width;
            this.product.originalHeight = this.product.height;
            this.product.aspectRatio = this.product.width / this.product.height;
            
            // NOTE: fixedFrame dimensions are ALWAYS 450x450 - set in constructor
            // We do NOT modify them based on product image dimensions
            
            // Update inputs
            this.widthInput.value = this.product.width;
            this.heightInput.value = this.product.height;
            
            // Load pictos
            const pictoData = {{ picto_data|safe }};
            
            for (const picto of pictoData.vertical || []) {
                try {
                    const img = await this.loadImage(picto.url);
                    this.verticalPictos.push({ img, x: picto.x, y: picto.y });
                } catch (e) {
                    console.warn('Failed to load vertical picto:', picto.url);
                }
            }
            
            for (const picto of pictoData.horizontal || []) {
                try {
                    const img = await this.loadImage(picto.url);
                    this.horizontalPictos.push({ img, x: picto.x, y: picto.y });
                } catch (e) {
                    console.warn('Failed to load horizontal picto:', picto.url);
                }
            }
            
            this.render();
            
        } catch (error) {
            console.error('Error loading images:', error);
        }
    }
    
    loadImage(src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = src;
        });
    }
    
    resizePicto(img, maxSize = 100) {
        let width = img.width;
        let height = img.height;
        
        if (width > height) {
            if (width > maxSize) {
                height = Math.round((height * maxSize) / width);
                width = maxSize;
            }
        } else {
            if (height > maxSize) {
                width = Math.round((width * maxSize) / height);
                height = maxSize;
            }
        }
        
        return { width, height };
    }
    
    render() {
        this.ctx.clearRect(0, 0, 800, 800);
        
        if (this.backgroundImg) {
            this.ctx.drawImage(this.backgroundImg, 0, 0, 800, 800);
        } else {
            this.ctx.fillStyle = '#ffffff';
            this.ctx.fillRect(0, 0, 800, 800);
        }
        
        if (this.productImg) {
            const drawX = this.product.x - this.product.width / 2;
            const drawY = this.product.y - this.product.height / 2;
            
            // Save context state
            this.ctx.save();
            
            if (this.product.flipped) {
                // Flip horizontally around the center point (product.x, product.y)
                // This keeps the image in the same position
                this.ctx.translate(this.product.x, this.product.y);
                this.ctx.scale(-1, 1);
                this.ctx.translate(-this.product.x, -this.product.y);
            }
            
            this.ctx.drawImage(this.productImg, drawX, drawY, this.product.width, this.product.height);
            
            // Restore context state
            this.ctx.restore();
        }
        
        for (const picto of this.verticalPictos) {
            const size = this.resizePicto(picto.img, 100);
            this.ctx.drawImage(picto.img, picto.x, picto.y, size.width, size.height);
        }
        
        for (const picto of this.horizontalPictos) {
            const size = this.resizePicto(picto.img, 100);
            this.ctx.drawImage(picto.img, picto.x, picto.y, size.width, size.height);
        }
        
        // Draw original center reference frame - ON TOP so it's always visible
        this.drawCenterReferenceFrame();
    }
    
    drawCenterReferenceFrame() {
        if (!this.showGuides) return;
        
        // FIXED frame values - ALWAYS 450x450, NEVER changes regardless of image dimensions
        // These values are hardcoded and will NEVER be affected by product image dimensions
        const centerX = 400;  // Fixed center X coordinate
        const centerY = 400;  // Fixed center Y coordinate
        const frameW = 450;   // Fixed width - ALWAYS 450 pixels
        const frameH = 450;   // Fixed height - ALWAYS 450 pixels
        
        // Frame color - BRIGHT RED for maximum visibility
        const frameColor = '#ff0000';
        
        // Save context state
        this.ctx.save();
        
        // ===== FIXED BORDER FRAME - Always 450x450 square =====
        const frameX = centerX - frameW / 2;  // 400 - 225 = 175
        const frameY = centerY - frameH / 2;  // 400 - 225 = 175
        
        // Draw the frame border - THICK RED LINE for maximum visibility
        this.ctx.strokeStyle = frameColor;
        this.ctx.lineWidth = 5; // Very thick for visibility
        this.ctx.globalAlpha = 1.0; // Full opacity
        this.ctx.lineJoin = 'miter';
        this.ctx.miterLimit = 10;
        
        // Draw the fixed 450x450 rectangle - this NEVER changes
        this.ctx.beginPath();
        this.ctx.rect(frameX, frameY, frameW, frameH);
        this.ctx.stroke();
        
        // Draw again with rounded corners for better appearance
        const cornerRadius = 8;
        this.ctx.beginPath();
        this.roundRect(frameX, frameY, frameW, frameH, cornerRadius);
        this.ctx.stroke();
        
        // ===== CENTER CROSSHAIR - Small "+" marker =====
        const crossSize = 15; // Larger for visibility
        
        this.ctx.strokeStyle = frameColor;
        this.ctx.lineWidth = 4; // Thick for visibility
        this.ctx.lineCap = 'round';
        
        // Horizontal line
        this.ctx.beginPath();
        this.ctx.moveTo(centerX - crossSize, centerY);
        this.ctx.lineTo(centerX + crossSize, centerY);
        this.ctx.stroke();
        
        // Vertical line
        this.ctx.beginPath();
        this.ctx.moveTo(centerX, centerY - crossSize);
        this.ctx.lineTo(centerX, centerY + crossSize);
        this.ctx.stroke();
        
        // Restore context state
        this.ctx.restore();
    }
    
    // Helper: rounded rectangle
    roundRect(x, y, w, h, r) {
        this.ctx.moveTo(x + r, y);
        this.ctx.lineTo(x + w - r, y);
        this.ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        this.ctx.lineTo(x + w, y + h - r);
        this.ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        this.ctx.lineTo(x + r, y + h);
        this.ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        this.ctx.lineTo(x, y + r);
        this.ctx.quadraticCurveTo(x, y, x + r, y);
    }
    
    reset() {
        this.product.x = 400;
        this.product.y = 400;
        this.product.width = this.product.originalWidth;
        this.product.height = this.product.originalHeight;
        this.product.flipped = false;  // Reset flip state
        
        this.widthInput.value = this.product.width;
        this.heightInput.value = this.product.height;
        
        // Update mirror button state
        const mirrorBtn = document.getElementById('modalMirrorBtn');
        if (mirrorBtn) {
            mirrorBtn.classList.remove('active');
        }
        
        this.render();
    }
    
    flipHorizontal() {
        // Toggle flip state
        this.product.flipped = !this.product.flipped;
        
        // Update button visual state
        const mirrorBtn = document.getElementById('modalMirrorBtn');
        if (mirrorBtn) {
            mirrorBtn.classList.toggle('active', this.product.flipped);
        }
        
        // Re-render with new flip state
        this.render();
    }
    
    downloadCustom() {
        const userFilename = prompt('Enter filename for custom download:', 'custom_result');
        if (userFilename === null) return;
        
        const cleanFilename = userFilename.replace(/[<>:"/\\|?*]/g, '_').trim();
        if (!cleanFilename) {
            alert('Filename cannot be empty!');
            return;
        }
        
        const finalFilename = cleanFilename.endsWith('.webp') ? cleanFilename : cleanFilename + '.webp';
        
        // Temporarily hide guides for clean export
        const guidesWereVisible = this.showGuides;
        this.showGuides = false;
        this.render();
        
        // Export canvas
        this.canvas.toBlob((blob) => {
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = finalFilename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
            
            // Restore guides visibility
            this.showGuides = guidesWereVisible;
            this.render();
        }, 'image/webp', 0.95);
    }
}

// Initialize modal preview editor
let modalPreviewEditor;
document.addEventListener('DOMContentLoaded', function() {
    modalPreviewEditor = new ModalPreviewEditor(
        'modalPreviewCanvas',
        'modalProductWidth',
        'modalProductHeight',
        'modalLockAspectRatio'
    );
});

// Open preview editor for a specific product
function openPreviewEditor(index, productImageUrl, resultImageUrl) {
    modalPreviewEditor.loadForProduct(productImageUrl);
    const modal = new bootstrap.Modal(document.getElementById('previewModal'));
    modal.show();
}
</script>
{% endblock %}
