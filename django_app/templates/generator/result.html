{% extends 'base.html' %}

{% block title %}Product Icon Generator - Result{% endblock %}

{% block content %}
<style>
    .preview-container {
        background: #1a1a2e;
        border-radius: 15px;
        padding: 20px;
        margin-top: 20px;
    }
    .preview-canvas-wrapper {
        position: relative;
        display: inline-block;
        border: 3px solid #667eea;
        border-radius: 10px;
        overflow: hidden;
        cursor: move;
    }
    #previewCanvas {
        display: block;
    }
    .preview-controls {
        background: rgba(255,255,255,0.1);
        border-radius: 10px;
        padding: 20px;
        margin-top: 15px;
    }
    .preview-controls label {
        color: #fff;
        font-weight: 500;
    }
    .preview-controls input[type="number"] {
        background: rgba(255,255,255,0.9);
        border: 2px solid #667eea;
        border-radius: 8px;
        padding: 8px 12px;
        width: 100px;
        font-weight: 600;
    }
    .preview-controls .form-check-label {
        color: #ccc;
    }
    .preview-title {
        color: #fff;
        font-size: 1.2rem;
        margin-bottom: 15px;
    }
    .btn-preview {
        border-radius: 25px;
        padding: 10px 25px;
        font-weight: 600;
        transition: all 0.3s ease;
    }
    .btn-edit {
        background: linear-gradient(45deg, #f39c12, #e74c3c);
        border: none;
        color: white;
    }
    .btn-edit:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 20px rgba(243, 156, 18, 0.4);
        color: white;
    }
    .btn-reset {
        background: linear-gradient(45deg, #95a5a6, #7f8c8d);
        border: none;
        color: white;
    }
    .btn-download-custom {
        background: linear-gradient(45deg, #27ae60, #2ecc71);
        border: none;
        color: white;
    }
    .editing-hint {
        color: #a0a0a0;
        font-size: 0.85rem;
        margin-top: 10px;
    }
</style>

<div class="row justify-content-center">
    <div class="col-md-10">
        <div class="card">
            <div class="card-header bg-success text-white text-center">
                <h3><i class="fas fa-check-circle me-2"></i>Product Image Generated Successfully!</h3>
            </div>
            <div class="card-body">
                <div class="row">
                    <!-- Original Image -->
                    <div class="col-md-6">
                        <div class="text-center">
                            <h5 class="mb-3"><i class="fas fa-image me-2"></i>Original Product</h5>
                            <img src="{{ submission.product_image.url }}" 
                                 alt="Original Product" 
                                 class="img-fluid rounded shadow"
                                 style="max-height: 300px;">
                        </div>
                    </div>
                    
                    <!-- Generated Image -->
                    <div class="col-md-6">
                        <div class="text-center">
                            <h5 class="mb-3"><i class="fas fa-magic me-2"></i>Generated Result</h5>
                            <img src="{{ submission.result_image.url }}" 
                                 alt="Generated Product" 
                                 class="img-fluid rounded shadow"
                                 style="max-height: 300px;"
                                 id="resultImage">
                        </div>
                    </div>
                </div>

                <hr class="my-4">

                <!-- Preview Editor Section -->
                <div class="preview-container">
                    <div class="text-center">
                        <h4 class="preview-title"><i class="fas fa-edit me-2"></i>Preview Mode - Edit Product Position & Size</h4>
                        
                        <div class="preview-canvas-wrapper" id="canvasWrapper">
                            <canvas id="previewCanvas" width="800" height="800"></canvas>
                        </div>
                        
                        <div class="preview-controls">
                            <div class="row justify-content-center align-items-center g-3">
                                <div class="col-auto">
                                    <label for="productWidth" class="me-2">Largeur:</label>
                                    <input type="number" id="productWidth" value="350" min="50" max="700" step="10">
                                </div>
                                <div class="col-auto">
                                    <label for="productHeight" class="me-2">Hauteur:</label>
                                    <input type="number" id="productHeight" value="350" min="50" max="700" step="10">
                                </div>
                                <div class="col-auto">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="lockAspectRatio" checked>
                                        <label class="form-check-label" for="lockAspectRatio">
                                            <i class="fas fa-lock me-1"></i>Lock Aspect Ratio
                                        </label>
                                    </div>
                                </div>
                            </div>
                            <div class="mt-3">
                                <button class="btn btn-preview btn-reset me-2" onclick="previewEditor.reset()">
                                    <i class="fas fa-undo me-1"></i>Reset to Default
                                </button>
                                <button class="btn btn-preview btn-download-custom" onclick="previewEditor.downloadCustom()">
                                    <i class="fas fa-download me-1"></i>Download Custom
                                </button>
                            </div>
                            <p class="editing-hint"><i class="fas fa-info-circle me-1"></i>Drag the product image to reposition it. Use the controls above to resize.</p>
                        </div>
                    </div>
                </div>

                <hr class="my-4">

                <div class="text-center">
                    <button onclick="downloadWithRename('{{ submission.result_image.url }}')" 
                            class="btn btn-success btn-lg me-3">
                        <i class="fas fa-download me-2"></i>Download Original Result
                    </button>
                    <a href="{% url 'home' %}" class="btn btn-primary btn-lg">
                        <i class="fas fa-plus me-2"></i>Generate Another
                    </a>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
// Download with rename function
function downloadWithRename(imageUrl) {
    const urlParts = imageUrl.split('/');
    let filename = urlParts[urlParts.length - 1];
    filename = filename.split('?')[0];
    const baseName = filename.replace(/\.[^/.]+$/, '') || 'result';
    
    const userFilename = prompt('Enter filename for download:', baseName);
    if (userFilename === null) return;
    
    const cleanFilename = userFilename.replace(/[<>:"/\\|?*]/g, '_').trim();
    if (!cleanFilename) {
        alert('Filename cannot be empty!');
        return;
    }
    
    const originalExt = filename.match(/\.[^/.]+$/) ? filename.match(/\.[^/.]+$/)[0] : '.webp';
    const finalFilename = cleanFilename.endsWith(originalExt) ? cleanFilename : cleanFilename + originalExt;
    
    fetch(imageUrl)
        .then(response => response.blob())
        .then(blob => {
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = finalFilename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        })
        .catch(error => {
            console.error('Download error:', error);
            alert('Error downloading image. Please try again.');
        });
}

// Preview Editor Class
class PreviewEditor {
    constructor(canvasId, options) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.options = options;
        
        // Canvas dimensions (scaled for display)
        this.displayScale = 0.6; // 60% of original for display
        this.canvas.style.width = (800 * this.displayScale) + 'px';
        this.canvas.style.height = (800 * this.displayScale) + 'px';
        
        // Images
        this.backgroundImg = null;
        this.productImg = null;
        this.verticalPictos = [];
        this.horizontalPictos = [];
        
        // Product state
        this.product = {
            x: 400, // Center X
            y: 400, // Center Y
            width: 350,
            height: 350,
            originalWidth: 350,
            originalHeight: 350,
            aspectRatio: 1
        };
        
        // Original center position (reference frame)
        this.originalCenter = {
            x: 400,
            y: 400
        };
        
        // Drag state
        this.isDragging = false;
        this.dragOffset = { x: 0, y: 0 };
        
        // Bind events
        this.bindEvents();
        
        // Load images
        this.loadImages();
    }
    
    bindEvents() {
        const wrapper = document.getElementById('canvasWrapper');
        
        // Mouse events
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        document.addEventListener('mousemove', (e) => this.onMouseMove(e));
        document.addEventListener('mouseup', () => this.onMouseUp());
        
        // Touch events for mobile
        this.canvas.addEventListener('touchstart', (e) => this.onTouchStart(e));
        document.addEventListener('touchmove', (e) => this.onTouchMove(e));
        document.addEventListener('touchend', () => this.onMouseUp());
        
        // Size inputs
        document.getElementById('productWidth').addEventListener('input', (e) => this.onWidthChange(e));
        document.getElementById('productHeight').addEventListener('input', (e) => this.onHeightChange(e));
    }
    
    getCanvasCoords(e) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = 800 / rect.width;
        const scaleY = 800 / rect.height;
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
        };
    }
    
    isPointInProduct(x, y) {
        const halfW = this.product.width / 2;
        const halfH = this.product.height / 2;
        return x >= this.product.x - halfW && 
               x <= this.product.x + halfW &&
               y >= this.product.y - halfH && 
               y <= this.product.y + halfH;
    }
    
    onMouseDown(e) {
        const coords = this.getCanvasCoords(e);
        if (this.isPointInProduct(coords.x, coords.y)) {
            this.isDragging = true;
            this.dragOffset.x = coords.x - this.product.x;
            this.dragOffset.y = coords.y - this.product.y;
            this.canvas.style.cursor = 'grabbing';
        }
    }
    
    onMouseMove(e) {
        if (!this.isDragging) return;
        
        const coords = this.getCanvasCoords(e);
        this.product.x = coords.x - this.dragOffset.x;
        this.product.y = coords.y - this.dragOffset.y;
        
        // Keep within bounds
        const halfW = this.product.width / 2;
        const halfH = this.product.height / 2;
        this.product.x = Math.max(halfW, Math.min(800 - halfW, this.product.x));
        this.product.y = Math.max(halfH, Math.min(800 - halfH, this.product.y));
        
        this.render();
    }
    
    onMouseUp() {
        this.isDragging = false;
        this.canvas.style.cursor = 'move';
    }
    
    onTouchStart(e) {
        e.preventDefault();
        const touch = e.touches[0];
        this.onMouseDown({ clientX: touch.clientX, clientY: touch.clientY });
    }
    
    onTouchMove(e) {
        if (!this.isDragging) return;
        e.preventDefault();
        const touch = e.touches[0];
        this.onMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
    }
    
    onWidthChange(e) {
        const newWidth = parseInt(e.target.value) || 350;
        const lockRatio = document.getElementById('lockAspectRatio').checked;
        
        this.product.width = newWidth;
        if (lockRatio) {
            this.product.height = Math.round(newWidth / this.product.aspectRatio);
            document.getElementById('productHeight').value = this.product.height;
        }
        this.render();
    }
    
    onHeightChange(e) {
        const newHeight = parseInt(e.target.value) || 350;
        const lockRatio = document.getElementById('lockAspectRatio').checked;
        
        this.product.height = newHeight;
        if (lockRatio) {
            this.product.width = Math.round(newHeight * this.product.aspectRatio);
            document.getElementById('productWidth').value = this.product.width;
        }
        this.render();
    }
    
    async loadImages() {
        try {
            // Load background
            this.backgroundImg = await this.loadImage('/backgrounds/background.jpg');
            
            // Load product image
            this.productImg = await this.loadImage('{{ submission.product_image.url }}');
            
            // Calculate initial product size maintaining aspect ratio
            const maxSize = 350;
            if (this.productImg.width > this.productImg.height) {
                this.product.width = maxSize;
                this.product.height = Math.round((this.productImg.height * maxSize) / this.productImg.width);
            } else {
                this.product.height = maxSize;
                this.product.width = Math.round((this.productImg.width * maxSize) / this.productImg.height);
            }
            this.product.originalWidth = this.product.width;
            this.product.originalHeight = this.product.height;
            this.product.aspectRatio = this.product.width / this.product.height;
            
            // Update original center reference to match initial position
            this.originalCenter.x = this.product.x;
            this.originalCenter.y = this.product.y;
            
            // Update input fields
            document.getElementById('productWidth').value = this.product.width;
            document.getElementById('productHeight').value = this.product.height;
            
            // Load pictos
            const pictoData = {{ picto_data|safe }};
            
            for (const picto of pictoData.vertical || []) {
                try {
                    const img = await this.loadImage(picto.url);
                    this.verticalPictos.push({ img, x: picto.x, y: picto.y });
                } catch (e) {
                    console.warn('Failed to load vertical picto:', picto.url);
                }
            }
            
            for (const picto of pictoData.horizontal || []) {
                try {
                    const img = await this.loadImage(picto.url);
                    this.horizontalPictos.push({ img, x: picto.x, y: picto.y });
                } catch (e) {
                    console.warn('Failed to load horizontal picto:', picto.url);
                }
            }
            
            // Initial render
            this.render();
            
        } catch (error) {
            console.error('Error loading images:', error);
        }
    }
    
    loadImage(src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = src;
        });
    }
    
    resizePicto(img, maxSize = 100) {
        let width = img.width;
        let height = img.height;
        
        if (width > height) {
            if (width > maxSize) {
                height = Math.round((height * maxSize) / width);
                width = maxSize;
            }
        } else {
            if (height > maxSize) {
                width = Math.round((width * maxSize) / height);
                height = maxSize;
            }
        }
        
        return { width, height };
    }
    
    render() {
        // Clear canvas
        this.ctx.clearRect(0, 0, 800, 800);
        
        // Draw background
        if (this.backgroundImg) {
            this.ctx.drawImage(this.backgroundImg, 0, 0, 800, 800);
        } else {
            this.ctx.fillStyle = '#ffffff';
            this.ctx.fillRect(0, 0, 800, 800);
        }
        
        // Draw original center reference frame (compass guide)
        this.drawCenterReferenceFrame();
        
        // Draw product (centered at x,y)
        if (this.productImg) {
            const drawX = this.product.x - this.product.width / 2;
            const drawY = this.product.y - this.product.height / 2;
            this.ctx.drawImage(this.productImg, drawX, drawY, this.product.width, this.product.height);
        }
        
        // Draw vertical pictos
        for (const picto of this.verticalPictos) {
            const size = this.resizePicto(picto.img, 100);
            this.ctx.drawImage(picto.img, picto.x, picto.y, size.width, size.height);
        }
        
        // Draw horizontal pictos
        for (const picto of this.horizontalPictos) {
            const size = this.resizePicto(picto.img, 100);
            this.ctx.drawImage(picto.img, picto.x, picto.y, size.width, size.height);
        }
    }
    
    drawCenterReferenceFrame() {
        const centerX = this.originalCenter.x;
        const centerY = this.originalCenter.y;
        const halfW = this.product.originalWidth / 2;
        const halfH = this.product.originalHeight / 2;
        const frameSize = Math.max(this.product.originalWidth, this.product.originalHeight) + 20;
        const cornerSize = 12;
        
        // Save context state
        this.ctx.save();
        
        // Draw outer frame (subtle dashed border) - acts as boundary guide
        this.ctx.strokeStyle = 'rgba(102, 126, 234, 0.35)';
        this.ctx.lineWidth = 2;
        this.ctx.setLineDash([10, 5]);
        this.ctx.strokeRect(
            centerX - frameSize / 2,
            centerY - frameSize / 2,
            frameSize,
            frameSize
        );
        
        // Draw inner frame (product size reference)
        this.ctx.strokeStyle = 'rgba(102, 126, 234, 0.65)';
        this.ctx.lineWidth = 2;
        this.ctx.setLineDash([6, 3]);
        this.ctx.strokeRect(
            centerX - halfW - 5,
            centerY - halfH - 5,
            this.product.originalWidth + 10,
            this.product.originalHeight + 10
        );
        
        // Draw corner indicators (L-shaped markers)
        this.ctx.strokeStyle = 'rgba(102, 126, 234, 0.8)';
        this.ctx.lineWidth = 2.5;
        this.ctx.setLineDash([]);
        
        // Top-left corner
        this.ctx.beginPath();
        this.ctx.moveTo(centerX - halfW - 5, centerY - halfH - 5);
        this.ctx.lineTo(centerX - halfW - 5, centerY - halfH - 5 + cornerSize);
        this.ctx.moveTo(centerX - halfW - 5, centerY - halfH - 5);
        this.ctx.lineTo(centerX - halfW - 5 + cornerSize, centerY - halfH - 5);
        this.ctx.stroke();
        
        // Top-right corner
        this.ctx.beginPath();
        this.ctx.moveTo(centerX + halfW + 5, centerY - halfH - 5);
        this.ctx.lineTo(centerX + halfW + 5, centerY - halfH - 5 + cornerSize);
        this.ctx.moveTo(centerX + halfW + 5, centerY - halfH - 5);
        this.ctx.lineTo(centerX + halfW + 5 - cornerSize, centerY - halfH - 5);
        this.ctx.stroke();
        
        // Bottom-left corner
        this.ctx.beginPath();
        this.ctx.moveTo(centerX - halfW - 5, centerY + halfH + 5);
        this.ctx.lineTo(centerX - halfW - 5, centerY + halfH + 5 - cornerSize);
        this.ctx.moveTo(centerX - halfW - 5, centerY + halfH + 5);
        this.ctx.lineTo(centerX - halfW - 5 + cornerSize, centerY + halfH + 5);
        this.ctx.stroke();
        
        // Bottom-right corner
        this.ctx.beginPath();
        this.ctx.moveTo(centerX + halfW + 5, centerY + halfH + 5);
        this.ctx.lineTo(centerX + halfW + 5, centerY + halfH + 5 - cornerSize);
        this.ctx.moveTo(centerX + halfW + 5, centerY + halfH + 5);
        this.ctx.lineTo(centerX + halfW + 5 - cornerSize, centerY + halfH + 5);
        this.ctx.stroke();
        
        // Draw crosshair lines (center alignment guides)
        this.ctx.strokeStyle = 'rgba(102, 126, 234, 0.55)';
        this.ctx.lineWidth = 1.5;
        this.ctx.setLineDash([4, 4]);
        
        // Horizontal line
        this.ctx.beginPath();
        this.ctx.moveTo(centerX - 60, centerY);
        this.ctx.lineTo(centerX + 60, centerY);
        this.ctx.stroke();
        
        // Vertical line
        this.ctx.beginPath();
        this.ctx.moveTo(centerX, centerY - 60);
        this.ctx.lineTo(centerX, centerY + 60);
        this.ctx.stroke();
        
        // Draw center point with glow effect
        // Outer glow
        this.ctx.fillStyle = 'rgba(102, 126, 234, 0.15)';
        this.ctx.beginPath();
        this.ctx.arc(centerX, centerY, 10, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Inner glow
        this.ctx.fillStyle = 'rgba(102, 126, 234, 0.3)';
        this.ctx.beginPath();
        this.ctx.arc(centerX, centerY, 6, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Center point
        this.ctx.fillStyle = 'rgba(102, 126, 234, 0.95)';
        this.ctx.beginPath();
        this.ctx.arc(centerX, centerY, 3.5, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Draw subtle shadow/outline for better visibility
        this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.lineWidth = 1;
        this.ctx.setLineDash([]);
        this.ctx.beginPath();
        this.ctx.arc(centerX, centerY, 4, 0, Math.PI * 2);
        this.ctx.stroke();
        
        // Restore context state
        this.ctx.restore();
    }
    
    reset() {
        this.product.x = this.originalCenter.x;
        this.product.y = this.originalCenter.y;
        this.product.width = this.product.originalWidth;
        this.product.height = this.product.originalHeight;
        
        document.getElementById('productWidth').value = this.product.width;
        document.getElementById('productHeight').value = this.product.height;
        
        this.render();
    }
    
    downloadCustom() {
        // Get filename from user
        const userFilename = prompt('Enter filename for custom download:', 'custom_result');
        if (userFilename === null) return;
        
        const cleanFilename = userFilename.replace(/[<>:"/\\|?*]/g, '_').trim();
        if (!cleanFilename) {
            alert('Filename cannot be empty!');
            return;
        }
        
        const finalFilename = cleanFilename.endsWith('.png') ? cleanFilename : cleanFilename + '.png';
        
        // Export canvas
        this.canvas.toBlob((blob) => {
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = finalFilename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }, 'image/png');
    }
}

// Initialize preview editor when DOM is ready
let previewEditor;
document.addEventListener('DOMContentLoaded', function() {
    previewEditor = new PreviewEditor('previewCanvas', {});
});
</script>
{% endblock %}
